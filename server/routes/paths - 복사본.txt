const express = require('express');
const oracledb = require('oracledb');
const router = express.Router();

// GPS 기록 종료 후 경로 저장
router.post('/save-gps-record', async (req, res) => {
    let connection;
    
    try {
        const { 
            pathName,
            pathDescription,
            pathTagNo,
            coordinates, // [{ lat, lng, type, order }]
            totalDistance,
            estimatedTime
        } = req.body;

        const userNo = process.env.TEMP_USER_NO; // 임시 사용자 번호

        if (!coordinates || coordinates.length === 0) {
            return res.status(400).json({
                success: false,
                message: '좌표 데이터가 필요합니다.'
            });
        }

        connection = await oracledb.getConnection();

        // 시작점 좌표
        const startPoint = coordinates.find(coord => coord.type === 'START') || coordinates[0];

        // 1. 경로 마스터 저장
        const pathResult = await connection.execute(
            `INSERT INTO PATHS 
             (PATH_NO, USER_NO, PATH_TAG_NO, START_LATITUDE, START_LONGITUDE, 
              PATH_NAME, PATH_DESCRIPTION, TOTAL_DISTANCE, ESTIMATED_TIME)
             VALUES (SEQ_PATHS.NEXTVAL, :userNo, :pathTagNo, :startLat, :startLng, 
                     :pathName, :pathDescription, :totalDistance, :estimatedTime)
             RETURNING PATH_NO INTO :pathNo`,
            {
                userNo: parseInt(userNo),
                pathTagNo: pathTagNo || null,
                startLat: startPoint.lat,
                startLng: startPoint.lng,
                pathName: pathName || null,
                pathDescription: pathDescription || null,
                totalDistance: totalDistance || null,
                estimatedTime: estimatedTime || null,
                pathNo: { type: oracledb.NUMBER, dir: oracledb.BIND_OUT }
            }
        );

        const pathNo = pathResult.outBinds.pathNo[0];

        // 2. 경로 타입 번호 매핑
        const typeMapping = await connection.execute(
            'SELECT PATH_TYPE_NO, PATH_TYPE_NAME FROM PATH_TYPES'
        );
        
        const typeMap = {};
        typeMapping.rows.forEach(row => {
            typeMap[row[1]] = row[0]; // 이름 -> 번호
        });

        // 3. 경로 디테일 저장
        const pathDetails = coordinates.map((coord, index) => ({
            pathNo,
            latitude: coord.lat,
            longitude: coord.lng,
            pathTypeNo: typeMap[coord.type] || typeMap['경유지'],
            waypointOrder: coord.order || index + 1,
            pointName: coord.name || null
        }));

        await connection.executeMany(
            `INSERT INTO PATH_DETAILS 
             (PATH_DETAIL_NO, PATH_NO, LATITUDE, LONGITUDE, PATH_TYPE_NO, WAYPOINT_ORDER, POINT_NAME)
             VALUES (SEQ_PATH_DETAILS.NEXTVAL, :pathNo, :latitude, :longitude, :pathTypeNo, :waypointOrder, :pointName)`,
            pathDetails
        );

        await connection.commit();

        res.json({
            success: true,
            pathNo: pathNo,
            message: 'GPS 기록이 성공적으로 저장되었습니다.'
        });

    } catch (error) {
        if (connection) {
            await connection.rollback();
        }
        console.error('GPS 기록 저장 실패:', error);
        res.status(500).json({
            success: false,
            message: 'GPS 기록 저장 중 오류가 발생했습니다.',
            error: error.message
        });
    } finally {
        if (connection) {
            await connection.close();
        }
    }
});

// 나의 산책길 조회 (회원번호 기준)
router.get('/my-paths', async (req, res) => {
    let connection;
    
    try {
        const userNo = process.env.TEMP_USER_NO; // 임시 사용자 번호
        
        connection = await oracledb.getConnection();

        const result = await connection.execute(
            `SELECT p.PATH_NO, p.PATH_NAME, p.PATH_DESCRIPTION, p.TOTAL_DISTANCE, 
                    p.ESTIMATED_TIME, p.CREATED_DATE, pt.PATH_TAG_NAME,
                    p.START_LATITUDE, p.START_LONGITUDE
             FROM PATHS p
             LEFT JOIN PATH_TAGS pt ON p.PATH_TAG_NO = pt.PATH_TAG_NO
             WHERE p.USER_NO = :userNo
             ORDER BY p.CREATED_DATE DESC`,
            { userNo: parseInt(userNo) }
        );

        const paths = result.rows.map(row => ({
            pathNo: row[0],
            pathName: row[1],
            pathDescription: row[2],
            totalDistance: row[3],
            estimatedTime: row[4],
            createdDate: row[5],
            pathTagName: row[6],
            startLatitude: row[7],
            startLongitude: row[8]
        }));

        res.json({
            success: true,
            paths: paths
        });

    } catch (error) {
        console.error('나의 산책길 조회 실패:', error);
        res.status(500).json({
            success: false,
            message: '나의 산책길 조회 중 오류가 발생했습니다.',
            error: error.message
        });
    } finally {
        if (connection) {
            await connection.close();
        }
    }
});

// 특정 경로의 상세 좌표 조회
router.get('/:pathNo/details', async (req, res) => {
    let connection;
    
    try {
        const { pathNo } = req.params;
        
        connection = await oracledb.getConnection();

        const pathResult = await connection.execute(
            `SELECT p.PATH_NAME, p.PATH_DESCRIPTION, p.TOTAL_DISTANCE, p.ESTIMATED_TIME,
                    pt.PATH_TAG_NAME, p.START_LATITUDE, p.START_LONGITUDE
             FROM PATHS p
             LEFT JOIN PATH_TAGS pt ON p.PATH_TAG_NO = pt.PATH_TAG_NO
             WHERE p.PATH_NO = :pathNo`,
            { pathNo: parseInt(pathNo) }
        );

        if (pathResult.rows.length === 0) {
            return res.status(404).json({
                success: false,
                message: '경로를 찾을 수 없습니다.'
            });
        }

        const detailResult = await connection.execute(
            `SELECT pd.LATITUDE, pd.LONGITUDE, pt.PATH_TYPE_NAME, 
                    pd.WAYPOINT_ORDER, pd.POINT_NAME
             FROM PATH_DETAILS pd
             INNER JOIN PATH_TYPES pt ON pd.PATH_TYPE_NO = pt.PATH_TYPE_NO
             WHERE pd.PATH_NO = :pathNo
             ORDER BY pd.WAYPOINT_ORDER`,
            { pathNo: parseInt(pathNo) }
        );

        const pathInfo = {
            pathName: pathResult.rows[0][0],
            pathDescription: pathResult.rows[0][1],
            totalDistance: pathResult.rows[0][2],
            estimatedTime: pathResult.rows[0][3],
            pathTagName: pathResult.rows[0][4],
            startLatitude: pathResult.rows[0][5],
            startLongitude: pathResult.rows[0][6]
        };

        const coordinates = detailResult.rows.map(row => ({
            latitude: row[0],
            longitude: row[1],
            type: row[2],
            order: row[3],
            name: row[4]
        }));

        res.json({
            success: true,
            path: pathInfo,
            coordinates: coordinates
        });

    } catch (error) {
        console.error('경로 상세 조회 실패:', error);
        res.status(500).json({
            success: false,
            message: '경로 상세 조회 중 오류가 발생했습니다.',
            error: error.message
        });
    } finally {
        if (connection) {
            await connection.close();
        }
    }
});

// 경로 태그 목록 조회
router.get('/tags', async (req, res) => {
    let connection;
    
    try {
        connection = await oracledb.getConnection();

        const result = await connection.execute(
            'SELECT PATH_TAG_NO, PATH_TAG_NAME FROM PATH_TAGS ORDER BY PATH_TAG_NAME'
        );

        const tags = result.rows.map(row => ({
            tagNo: row[0],
            tagName: row[1]
        }));

        res.json({
            success: true,
            tags: tags
        });

    } catch (error) {
        console.error('태그 조회 실패:', error);
        res.status(500).json({
            success: false,
            message: '태그 조회 중 오류가 발생했습니다.',
            error: error.message
        });
    } finally {
        if (connection) {
            await connection.close();
        }
    }
});

module.exports = router;
